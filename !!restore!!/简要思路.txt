********************************************************
***********打通tendermint和ethereum账号*****************
********************************************************

在genesis.json中：
1，在validators中增加eth_account字段；如果没有设置或者配置了而不存在该账号，则退出
2，配置validators中对应的amount，如果没有设置或者设置了而对应的eth_account的以太币不够，则退出
3，在单节点刚启动运行时，如果没有priv_validator.json和genesis.json，则eth_account默认为coinbase，amount为10


检查：
1，在ethermint中，在进行初始化时，嵌入检查eth_account和amount的代码
2，在ethereum中，进行交易燃烧Gas或者转账时，如果牵涉到eth_account，要检查余额(balance)不能少于定义的amount
3，在tendermint中，在进行共识时检查eth_account是否有足够的amount


思路更新：
1，为account增加deposit字段，专门用来参与投票，记录为权重。该字段与balance类似，也是币的数量，不可消费。可以申请把币从balance中转入deposit，在下一个epoch中生效；也可以申请从deposit中转入balance，在下下个epoch中生效。


********************************************************
***************增加、减少validator命令******************
********************************************************

1，支持命令行和RPC两种模式；前者支持高级手动用户，后者支持客户端
2，增加 validator 系列命令，以 validator 为前缀，增加命令如下：
 ethermint validator list		//展示当前epoch，区块高度，大约多少区块/时间后进入下一个epoch
 ethermint validator join [epoch=xx] [height=xx] [amount=xx] [key=xx]//从哪一个epoch，区块，以多少币开始加入。指定的epoch和区块所确定的epoch如果不一致，以先到达的为准。如果没有指定，从下一个epoch开始加入
 ethermint validator withdraw [epoch=xx] [height=xx] [amount=xx] [key=xx]	//从哪一个epoch，区块开始退出，退出多少数量。指定的epoch和区块所确定的epoch如果不一致，以先到达为准。没有指定的话是下一个epoch，彻出所有抵押
 ethermint validator accept [address=xx] //接受某一个地址
 ethermint validator deny [address=xx] //拒绝某一个地址
3，发起申请、拒绝等操作，均需要用私钥进行签名


********************************************************
***************就RewardScheme和Epoch达成共识************
********************************************************
1, //进入新的一轮投票前，进行是否进入新的Epoch的验证
func (cs *ConsensusState) enterNewRound(height int, round int) {
	cs.rewardScheme.EnterNewEpoch(height)
}

2, //创建Proposal，发送ProposalMessage和BlockPartMessage消息；携带RewardScheme及建议的NextEpoch信息
defaultDecideProposal -> (cs *ConsensusState)createProposalBlock() -> MakeBlock() {
	rs.SetNextEpoch(rs.ProposeNextEpoch())
}

3, //preVote阶段，验证RewardScheme及建议的NextEpoch是否符合本节点运行情况，符合投票，不符合投nil
func (cs *ConsensusState) enterPrevote() {
	cs.rewardScheme.Validate(cs.ProposalBlock.Data.RS, true)
}

4, //commit阶段，将NextEpoch信息写入Block 及 DB 中
func (cs *ConsensusState) finalizeCommit() {
	cs.rewardScheme.Flush(height)
}

5, //追赶新的Block，进行replay时进行验证，看本地Epoch信息是否和下载的一致，是则持续更新，否则报告异常并退出
func (s *State)ApplyBlock() {
	rs.Flush(block.Header.Height)
}


4和5只需要一个
目前，为了减少代码的改动，目前在State中临时保存当前的Epoch；后面考虑要不要把Epoch单独拿出来使用


?? reward scheme 要不要写入wal
?? 要不要写入state


********************************************************
***************新增同步机制******************
********************************************************
1，类似于validator和block的同步机制，需要实现统一的同步机制就epoch/reward等各种系统设置进行投票，形成共识


 ********************************************************
 *****************开发客户端、钱包***********************
 ********************************************************
 1，需要开发客户端（钱包）来进行转账、查询等简单的基本功能
 2，需要能支持申请成为validator、批准validator加入等功能


 ********************************************************
 *************************计费系统***********************
 ********************************************************

 1，调用主链智能合约外的服务时，侧链发起者也要支付费用；例如注册、除区块头存证外的数据存储
